# Ответы на вопросы к Лабораторной работе №13

## 1. Что такое сериализация, десериализация?
**Сериализация** — это процесс преобразования состояния объекта в форму, пригодную для сохранения (например, в файл, базу данных) или передачи (по сети).
**Десериализация** — обратный процесс восстановления объекта из сериализованного состояния (потока байтов, XML, JSON и т.д.).

## 2. Какие существуют форматы сериализации?
*   **Binary (Бинарный):** Компактный формат, сохраняет состояние объекта в виде последовательности байтов. Зависит от платформы и версии сборки. В .NET Core/5+ считается устаревшим и небезопасным (`BinaryFormatter`).
*   **SOAP:** Основан на XML, используется для обмена сообщениями в веб-сервисах. Более тяжеловесный, чем чистый XML. Устарел.
*   **XML:** Текстовый формат, читаемый человеком. Хорошо подходит для обмена данными между разными системами. Использует теги.
*   **JSON:** Текстовый формат, основанный на парах ключ-значение. Легковесный, широко используется в веб-приложениях.

**Классы в .NET:**
*   Binary: `System.Runtime.Serialization.Formatters.Binary.BinaryFormatter` (Useless in modern .NET)
*   XML: `System.Xml.Serialization.XmlSerializer`, `System.Runtime.Serialization.DataContractSerializer`
*   JSON: `System.Text.Json.JsonSerializer` (современный), `System.Runtime.Serialization.Json.DataContractJsonSerializer`, `Newtonsoft.Json` (сторонний, но популярный).

## 3. Какие классы существуют в пространстве имен System.Xml?
Основные классы:
*   `XmlDocument`, `XmlNode`, `XmlElement` (классический DOM).
*   `XmlReader`, `XmlWriter` (потоковое чтение/запись).
*   `XmlSerializer` (сериализация).
*   `XDocument`, `XElement`, `XAttribute` (LINQ to XML, более современный API).
*   `XPathNavigator` (навигация с помощью XPath).

## 4. Какие атрибуты используются для настройки XML сериализации?
*   `[XmlRoot]` — корневой элемент.
*   `[XmlElement]` — имя элемента XML.
*   `[XmlAttribute]` — атрибут элемента.
*   `[XmlIgnore]` — исключить поле/свойство из сериализации.
*   `[XmlInclude]` — включить производные классы (для полиморфизма).
*   `[XmlArray]`, `[XmlArrayItem]` — настройка коллекций.

## 5. В чем отличие BinaryFormatter или SoapFormatter?
*   **BinaryFormatter**: Генерирует компактный бинарный поток. Очень быстр (в старых версиях), но специфичен для .NET и небезопасен. Сохраняет полную информацию о типах.
*   **SoapFormatter**: Генерирует XML в формате SOAP. Читаем человеком, но избыточен. Позволял проходить через брандмауэры (как текст), но сейчас практически не используется.

## 6. Что такое сериализация контрактов данных, контракт данных?
**Data Contract (Контракт данных)** — это абстрактное описание данных, которыми обмениваются службы. В WCF используется атрибут `[DataContract]` для класса и `[DataMember]` для полей. Это позволяет отвязать структуру данных от конкретных типов .NET и управлять сериализацией более гибко.

## 7. Где и для чего используются атрибуты [OnSerializing], [OnSerialized], [OnDeserializing], [OnDeserialized]?
Эти атрибуты используются для выполнения кода в определенные моменты процесса сериализации/десериализации (например, для инициализации полей, которые не сериализуются, или коррекции данных после загрузки).
*   `[OnSerializing]`: Перед началом сериализации.
*   `[OnSerialized]`: После окончания сериализации.
*   `[OnDeserializing]`: Перед началом десериализации.
*   `[OnDeserialized]`: После окончания десериализации.

## 8. Что такое XPath? Приведите пример.
**XPath** (XML Path Language) — язык запросов к элементам XML-документа. Позволяет выбирать узлы по пути, условиям и т.д.
Пример: `//Product[Price > 100]` — выбрать все элементы `Product` (на любой глубине), у которых дочерний элемент `Price` больше 100.

## 9. Какие возможности дает LINQ to Xml. Приведите примеры
**LINQ to XML** (`System.Xml.Linq`) предоставляет удобный программный интерфейс для создания, изменения и запросов к XML документам, используя синтаксис LINQ (как для коллекций).
Возможности:
*   Создание XML через конструкторы (`new XElement(...)`).
*   Выборка данных (`from x in doc.Descendants...`).
*   Изменение структуры "на лету".
Пример:
```csharp
var names = from p in xdoc.Descendants("Product")
            where (int)p.Element("Price") > 100
            select p.Element("Name").Value;
```

---

# Как реализован проект (Пояснение для начинающих)

Представь, что ты играешь в компьютерную игру. Когда ты нажимаешь "Сохранить", игра берет всех твоих персонажей, их здоровье, инвентарь и записывает это в файл на диске. Когда ты нажимаешь "Загрузить", она читает файл и восстанавливает мир. В программировании этот процесс записи называется **сериализация**, а восстановления — **десериализация**.

Вот что конкретно мы сделали в этом проекте, разложенное по полочкам:

### 1. Подготовка "Фигурок" (Классы в папке L4)
У нас есть код из прошлой работы: Люди (`Person`) и Товары (`Product`). Чтобы компьютер знал, как их "сохранять", мы должны были их пометить.
*   **Наведение порядка:** Сначала мы разложили весь код по разным файлам (`Person.cs`, `Cake.cs` и т.д.), чтобы не запутаться.
*   **Атрибут `[Serializable]`:** Мы написали эту фразу над каждым классом. Это как печать "Разрешено к вывозу". Без неё некоторые старые механизмы сохранения не сработали бы.
*   **Проблема с наследством (Полиморфизм):** У нас есть просто "Товар", а есть "Торт" и "Часы". Когда мы сохраняем список товаров, компьютеру нужно знать, что первый товар — это именно Торт (с начинкой), а второй — Часы (с механизмом).
    *   Мы добавили атрибуты `[XmlInclude]` и `[JsonDerivedType]`. Это подсказки для программы: "Если встретишь Торт, сохраняй его как Торт, а не просто как Товар".
*   **Секреты:** У человека есть поле `SecretPassword`. Мы не хотим сохранять пароли в файл, чтобы их не украли. Мы пометили его атрибутами `[NonSerialized]`, `[XmlIgnore]`, `[JsonIgnore]`. Это значит: "При сохранении пропусти это поле".

### 2. Универсальный "Переводчик" (`Serializer.cs`)
Мы создали класс `CustomSerializer`. Представь, что это устройство-переводчик.
*   Ты даешь ему объект (Человека).
*   Говоришь язык (формат): "Переведи в JSON" или "Переведи в XML".
*   Он создает файл с переводом.

**Какие языки (форматы) мы использовали:**
*   **JSON:** Выглядит как текст: `{"Name": "Alex", "Age": 25}`. Самый популярный сейчас.
*   **XML:** Выглядит как теги: `<Name>Alex</Name>`. Похож на HTML.
*   **Binary:** Старый машинный формат. Современный C# его не любит (считает небезопасным), поэтому мы добавили защиту (`try-catch`), чтобы программа не ломалась, если он не сработает.

### 3. Главная программа (`Program.cs`) — Сценарий работы
Здесь мы проверяем, как всё работает:
1.  **Создаем данные:** Создаем парня по имени Алексей, даем ему Торт в инвентарь и пароль.
2.  **Тест сохранения:** Мы просим наш "Переводчик" сохранить Алексея в файлы `person.json` и `person.xml`. Потом загружаем обратно и проверяем: имя есть, торт есть, а **пароля нет** (потому что мы запретили его сохранять).
3.  **Тест списка:** Мы сохраняем список разных вещей (Торт, Цветы, Часы). Проверяем, что после загрузки Часы остались Часами (сохранился их механизм), а Цветы — Цветами.
4.  **Усложненное задание (Сокеты):** Мы сымитировали работу сети.
    *   **Клиент:** Превращает Алексея в текст (JSON) и отправляет по "проводу" (сокету).
    *   **Сервер:** Сидит и ждет. Получает текст, превращает его обратно в Алексея и пишет: "Я получил Алексея с балансом 500".
    Это база того, как работают сайты и онлайн-игры.
5.  **Поиск в XML:**
    *   **XPath:** Это способ искать в файле, не читая его целиком кодом. Мы сказали: "Найди мне все продукты, которые стоят больше 0 рублей".
    *   **LINQ to XML:** Это способ писать запросы к XML прямо на языке C#. Мы создали новый XML файл магазина прямо из кода и выбрали оттуда дорогие товары.
