# Ответы на теоретические вопросы

### 1. Что такое делегат? Как определить делегат?

**Делегат** — это ссылочный тип данных в .NET, который представляет собой "указатель" на метод с определенной сигнатурой (списком параметров и типом возвращаемого значения). Делегаты позволяют передавать методы как параметры другим методам, хранить их в полях или свойствах и вызывать их динамически во время выполнения программы. Они являются основой для реализации событий и обратных вызовов в C#.

**Определить делегат** можно с помощью ключевого слова `delegate`, указывая тип возвращаемого значения и типы параметров.

**Пример:**
```csharp
// Делегат для метода, который не принимает параметров и ничего не возвращает.
public delegate void MyAction();

// Делегат для метода, который принимает два int и возвращает int.
public delegate int MathOperation(int a, int b);
```

### 2. Назначение делегатов.

Основное назначение делегатов — реализация механизма **обратного вызова (callback)** и построение **событийно-ориентированных моделей**.

Ключевые сценарии использования:
1.  **События:** Делегаты лежат в основе системы событий. Объект-издатель (publisher) вызывает делегат, а объекты-подписчики (subscribers) предоставляют методы, которые будут выполнены при наступлении события.
2.  **Передача методов в качестве аргументов:** Позволяет настраивать поведение одного метода с помощью другого. Классический пример — методы сортировки, которые принимают делегат для сравнения элементов.
3.  **Асинхронное программирование:** Используются для указания метода, который должен выполниться после завершения асинхронной операции.
4.  **LINQ:** Многие методы LINQ (например, `Where`, `Select`) принимают в качестве параметров делегаты (часто в виде лямбда-выражений) для выполнения операций над коллекциями.

### 3. Какие есть способы присваивания делегату адреса метода?

Существует несколько способов:

1.  **Прямое присваивание имени метода:** Создается новый экземпляр делегата, который указывает на конкретный статический или экземплярный метод.
    ```csharp
    public int Add(int a, int b) => a + b;
    
    MathOperation op = Add; // Компилятор неявно создает new MathOperation(Add)
    ```

2.  **Использование анонимного метода (C# 2.0 и выше):** Позволяет определить "встроенный" безымянный метод.
    ```csharp
    MathOperation op = delegate(int x, int y)
    {
        return x + y;
    };
    ```

3.  **Использование лямбда-выражения (C# 3.0 и выше):** Наиболее краткий и распространенный способ.
    ```csharp
    MathOperation op = (x, y) => x + y;
    ```

### 4. Поясните назначение метода Invoke.

Метод `Invoke` используется для **явного вызова** делегата. Когда вы вызываете делегат как метод, компилятор C# на самом деле преобразует этот вызов в вызов метода `Invoke`.

```csharp
MathOperation op = (a, b) => a + b;

// Эти две строки эквивалентны:
int result1 = op(5, 10);        // Неявный вызов
int result2 = op.Invoke(5, 10); // Явный вызов
```

Основная польза от `Invoke` проявляется в двух случаях:
1.  **Многопоточность:** В GUI-приложениях (WinForms, WPF) для выполнения кода в потоке пользовательского интерфейса из другого потока. Например, `this.Invoke(...)`.
2.  **Проверка на `null`:** При работе с событиями безопасный вызов подписчиков выполняется с помощью условного оператора `?.` и `Invoke`, что является сокращенной записью проверки делегата на `null`.
    ```csharp
    MyEvent?.Invoke(this, EventArgs.Empty);
    ```

### 5. Что такое групповая адресация делегата?

**Групповая адресация (multicasting)** — это способность одного экземпляра делегата ссылаться не на один, а на несколько методов одновременно. Такие делегаты называются **многоадресными**. При вызове такого делегата последовательно вызываются все методы, на которые он ссылается, в том порядке, в котором они были добавлены.

Методы добавляются в цепочку с помощью оператора `+=`, а удаляются с помощью `-=`.

**Пример:**
```csharp
public void Method1() { Console.WriteLine("Метод 1"); }
public void Method2() { Console.WriteLine("Метод 2"); }

MyAction multicast = Method1;
multicast += Method2; // Теперь делегат ссылается на Method1 и Method2

multicast(); // Вызовет сначала Method1, потом Method2
/*
Вывод:
Метод 1
Метод 2
*/

multicast -= Method1; // Удаляем Method1 из цепочки
multicast(); // Вызовет только Method2
```
Если многоадресный делегат возвращает значение, то результатом его вызова будет значение, возвращенное **последним** методом в цепочке.

### 6. Как создать событие?

Событие создается в классе с помощью ключевого слова `event`, за которым следует тип делегата и имя события.

**Простое объявление:**
```csharp
public class MyPublisher
{
    // 1. Объявляем делегат
    public delegate void MyEventHandler(string message);

    // 2. Объявляем событие на основе этого делегата
    public event MyEventHandler? DataChanged;
}
```

Событие, по сути, является "оберткой" над делегатом, которая ограничивает доступ к нему. Извне класса можно только добавлять (`+=`) и удалять (`-=`) обработчики. Вызвать событие (т.е. делегат) можно **только изнутри класса**, в котором оно объявлено. Это обеспечивает инкапсуляцию и безопасность.

### 7. Как события связаны с делегатами? Опишите и поясните схему взаимодействия.

События и делегаты неразрывно связаны. Делегат определяет **"контракт"** (сигнатуру) для методов-обработчиков, а событие предоставляет **безопасный механизм** для подписки, отписки и вызова этих обработчиков.

**Схема взаимодействия:**
1.  **Издатель (Publisher):** Класс, который содержит событие. Он определяет, когда событие должно произойти.
    - Внутри издателя объявляется **делегат**, описывающий сигнатуру обработчиков.
    - На основе этого делегата объявляется **событие** с ключевым словом `event`.
    - Издатель содержит метод, который вызывает событие (через `Invoke`), уведомляя всех подписчиков.

2.  **Подписчик (Subscriber):** Класс, который заинтересован в событии.
    - Он содержит метод-обработчик, сигнатура которого **соответствует** делегату события.
    - Подписчик использует оператор `+=` на событии издателя, чтобы зарегистрировать свой обработчик.
    - При необходимости он может отписаться с помощью оператора `-=`.

**Пояснение схемы:**
- **Издатель** не знает ничего о подписчиках. Его единственная задача — сообщить о наступлении события.
- **Подписчик** знает об издателе (чтобы подписаться на его событие), но издатель не знает о подписчике.
- **Делегат** выступает в роли посредника, связывая издателя и подписчиков, обеспечивая слабую связанность системы.

Эта модель позволяет создавать гибкие и расширяемые архитектуры, где компоненты взаимодействуют, не имея жестких зависимостей друг от друга.

### 8. Что такое лямбда-выражения? Приведите пример лямбда-выражения с несколькими параметрами.

**Лямбда-выражение** — это анонимная функция, которая позволяет кратко определять методы "по месту" их использования. Это синтаксический сахар над анонимными методами.

Структура лямбда-выражения:
`(параметры) => { тело выражения }`

- `=>` — лямбда-оператор.
- Слева от него — список параметров (может быть пустым).
- Справа — тело метода. Если тело состоит из одного выражения, фигурные скобки и `return` можно опустить.

Лямбда-выражения широко используются с делегатами, особенно в LINQ и при подписке на события.

**Пример лямбда-выражения с несколькими параметрами:**
```csharp
// Делегат, принимающий две строки и возвращающий int
Func<string, string, int> stringComparer = (str1, str2) => str1.Length.CompareTo(str2.Length);

int result = stringComparer("hello", "world!"); // result = -1

// Подписка на событие с помощью лямбды
programmer.Delete += () => {
    Console.WriteLine($"Программист вызвал удаление.");
};
```

### 9. Что такое ковариантность и контравариантность делегатов? Что это дает?

Это принципы, позволяющие более гибко работать с типами в делегатах.

**Ковариантность** (ключевое слово `out`)
- Позволяет присваивать делегату метод, который возвращает **более производный** тип, чем указан в сигнатуре делегата.
- Работает только для возвращаемых значений.
- *Пример:* Если делегат должен вернуть `object`, ему можно присвоить метод, который возвращает `string`, так как `string` наследуется от `object`.

**Контравариантность** (ключевое слово `in`)
- Позволяет присваивать делегату метод, который принимает параметры **более базового** типа, чем указан в сигнатуре делегата.
- Работает только для параметров.
- *Пример:* Если делегат должен принимать параметр типа `string`, ему можно присвоить метод, который принимает `object`, так как `string` можно безопасно привести к `object`.

**Что это дает?**
Эти механизмы увеличивают гибкость кода. Они позволяют использовать более общие или, наоборот, более конкретные методы в качестве обработчиков, не создавая лишних "адаптеров" и не прибегая к явному приведению типов. Это делает код более чистым и интуитивно понятным.

### 10. Поясните разницу между встроенными делегатами Action и Func.

`Action` и `Func` — это стандартные, предопределенные в .NET делегаты, которые позволяют избежать создания собственных типов делегатов для самых распространенных случаев.

**`Action<...>`**
- Используется для инкапсуляции методов, которые **не возвращают значение** (`void`).
- Существуют перегрузки с разным количеством параметров (от 0 до 16):
  - `Action` — нет параметров.
  - `Action<T>` — один параметр типа `T`.
  - `Action<T1, T2>` — два параметра и т.д.

**`Func<..., TResult>`**
- Используется для инкапсуляции методов, которые **возвращают значение**.
- Последний generic-параметр в `Func` — это **всегда тип возвращаемого значения**.
- Также имеет перегрузки с разным количеством входных параметров:
  - `Func<TResult>` — нет параметров, возвращает `TResult`.
  - `Func<T, TResult>` — один параметр типа `T`, возвращает `TResult`.
  - `Func<T1, T2, TResult>` — два параметра, возвращает `TResult`.

**Ключевое различие:**
- **`Action` => Действие => `void`**
- **`Func` => Функция => `return value`**
```csharp
// Action: принимает int, ничего не возвращает
Action<int> printNumber = (n) => Console.WriteLine(n);
printNumber(10);

// Func: принимает два int, возвращает int
Func<int, int, int> sum = (a, b) => a + b;
int result = sum(5, 3); // result = 8
```
Также существует делегат `Predicate<T>`, который является частным случаем `Func<T, bool>`. Он всегда принимает один параметр и возвращает `bool`, обычно для проверки некоторого условия.

## Объяснение проекта (Вариант 9)

### Задание 1: Делегаты, события и лямбда-выражения

В рамках этого задания были реализованы следующие компоненты:

1.  **Делегаты `DeleteHandler` и `MutateHandler`**: Определяют сигнатуры методов, которые могут быть подписаны на события `Delete` и `Mutate` соответственно.
2.  **Класс `Programmer`**: Выступает в роли "издателя" событий. Он имеет два события:
    *   `Delete`: Инициируется для удаления данных.
    *   `Mutate`: Инициируется для изменения данных.
    Методы `TriggerDelete()` и `TriggerMutate()` используются для вызова соответствующих событий.
3.  **Класс `DataList`**: Представляет собой объект, хранящий список строк (`List<string>`). Он выступает в роли "подписчика" и содержит методы для реакции на события:
    *   `RemoveFirst()`: Удаляет первый элемент из списка.
    *   `RemoveLast()`: Удаляет последний элемент из списка.
    *   `Shuffle()`: Перемешивает элементы списка в случайном порядке.
    *   Метод `ToString()` переопределен для удобного вывода состояния списка.
4.  **Реализация в `Main`**:
    *   Создан экземпляр класса `Programmer`.
    *   Создано несколько экземпляров `DataList` с различными начальными данными.
    *   Объекты `DataList` были подписаны на события `Programmer` с использованием лямбда-выражений:
        *   `list1` подписан на `Delete` (удаляет первый элемент).
        *   `list2` подписан на `Mutate` (перемешивает список).
        *   `list3` подписан на оба события: `Delete` (удаляет последний элемент) и `Mutate` (перемешивает список).
        *   `list4` не подписан ни на одно событие, чтобы показать, что он остается неизменным.
    *   Последовательно вызываются события `Delete` и `Mutate`, демонстрируя реакцию подписанных объектов и отсутствие реакции у неподписанного.

### Задание 2: Обработка строк

В этой части задания реализован конвейер обработки строк с использованием стандартных делегатов `Func`, `Predicate` и `Action`:

1.  **Статический класс `StringManipulator`**: Содержит пять методов для обработки строк:
    *   `RemoveVowels(string s)`: Удаляет гласные буквы.
    *   `AddStars(string s)`: Добавляет звездочки по краям строки.
    *   `ReverseWords(string s)`: Переворачивает каждое слово в строке.
    *   `RemoveExtraSpaces(string s)`: Удаляет лишние пробелы.
    *   `CountChars(string s)`: Добавляет к строке информацию о её длине.
2.  **Реализация в `Main`**:
    *   Определена тестовая строка `testString`.
    *   **`Func<string, string> processingPipeline`**: Создана цепочка обработки, к которой последовательно добавлены методы из `StringManipulator`. Каждый метод принимает строку и возвращает измененную строку.
    *   **`Predicate<string> shouldProcess`**: Определяет условие, при котором строка будет обрабатываться (в данном случае, если она не пустая и не состоит только из пробелов).
    *   **`Action<string> printResult`**: Определяет действие для вывода конечного результата обработки.
    *   Происходит проверка строки с помощью `Predicate`, а затем, если условие выполняется, строка проходит через все методы в `processingPipeline`. После каждого этапа выводится промежуточный результат, и в конце — итоговый.
