# Лабораторная работа №7: Обобщения

В этом файле представлены решения и объяснения для лабораторной работы №7.

## Выполнение заданий

### Задание 1-4: Обобщенный интерфейс, класс, ограничения и тесты

**Код был реализован в файле `L3/Program.cs`**

#### Шаг 1: Обобщенный интерфейс `IActions<T>`
В соответствии с заданием 1, был создан обобщенный интерфейс `IActions<T>`, который определяет три основных действия с коллекцией:
- `Add(T item)`: Добавление элемента.
- `Remove(T item)`: Удаление элемента.
- `Show()`: Просмотр содержимого.

```csharp
public interface IActions<T>
{
    void Add(T item);
    void Remove(T item);
    void Show();
}
```

#### Шаг 2: Обобщенный класс `CollectionType<T>` и `SimpleCollection<T>`
Изначальный план был создать один класс `CollectionType<T>`. Однако, задание требует наложить ограничение на обобщение и при этом проверить работу со стандартными типами (`int`, `string`). Стандартные типы не соответствуют всем возможным ограничениям (например, `ICloneable` или `new()`).

Поэтому было принято решение разделить логику:
1.  **`SimpleCollection<T>`**: Базовый обобщенный класс, реализующий интерфейс `IActions<T>`. Он не имеет ограничений и используется для работы со стандартными типами (`int`, `string`), как того требует **задание 3**.
2.  **`CollectionType<T>`**: Класс, который наследуется от `SimpleCollection<T>` и добавляет более сложную функциональность. На этот класс наложено ограничение `where T: ICloneable, new()`, как пример выполнения **задания 2**. Это означает, что тип `T` должен реализовывать интерфейс `ICloneable` и иметь конструктор без параметров. Этот класс используется для работы с пользовательским типом `Production`.

#### Шаг 3: Обработка исключений
В классе `CollectionType<T>` (в первоначальной версии) была добавлена обработка исключений `try-catch-finally` для демонстрации. Например, при попытке добавить `null` или удалить несуществующий элемент генерировались и обрабатывались исключения.

#### Шаг 4: Пользовательский тип `Production`
Для **задания 4** изначальный класс `Production` из проекта `L3` был сделан публичным и вынесен наружу. Чтобы он соответствовал ограничению `where T: ICloneable, new()`, ему были добавлены:
- Реализация интерфейса `ICloneable`.
- Публичный конструктор без параметров.

### Задание 5: Сохранение и чтение из файла
В класс `CollectionType<T>` были добавлены методы для сериализации (сохранения) и десериализации (загрузки) коллекции в файл формата **JSON**.
- `SaveToFile(string filePath)`: Сериализует список `items` в JSON и сохраняет в файл.
- `LoadFromFile(string filePath)`: Читает данные из JSON-файла и загружает их в коллекцию.

Для работы с JSON используется встроенная библиотека `System.Text.Json`.

### Демонстрация в `Main`
В методе `Main` последовательно демонстрируется работа всех созданных классов и методов:
1.  Тестирование `SimpleCollection<T>` с `int` и `string`.
2.  Тестирование `CollectionType<T>` с пользовательским классом `Production`.
3.  Демонстрация поиска по предикату.
4.  Демонстрация сохранения коллекции в `collection.json` и загрузки ее в новый экземпляр класса.

## Ответы на вопросы

**1. Что такое обобщение (generic)?**
Обобщение (generic) — это механизм в C#, который позволяет создавать классы, интерфейсы, методы и структуры, работающие с любым типом данных, не указывая его заранее. Тип данных определяется как параметр (например, `T`) в момент создания экземпляра класса или вызова метода. Это повышает переиспользование кода, типобезопасность и производительность, так как позволяет избежать лишних преобразований типов.

**2. Пусть дан фрагмент листинга. В какой строчке содержится ошибка?**
```csharp
class Gen<T,G> //1
{
    G ob;//2
    T bo;//3
    public Gen(G o) { ob = o; } //4 -- В PDF здесь была опечатка (G o -> Go)
    public T GetOb() { return bo; } //5
}
```
Если рассматривать код как в PDF (`public Gen(Go) { ob = 0; }`), то ошибка находится в **строке 4**.
- `Go`: Компилятор воспримет это как неизвестный тип `Go`, а не как `G o`. Синтаксис объявления параметра — `[тип] [имя]`.
- `ob = 0;`: Нельзя присвоить `0` переменной обобщенного типа `G`, так как `G` может быть любым типом, несовместимым с `int`.

**3. Как можно наложить определенное ограничение на параметр?**
С помощью ключевого слова `where` после объявления имени класса или метода.
`class MyClass<T> where T : SomeBaseClass { ... }`

**4. Как можно наложить несколько ограничений на параметр?**
Перечислить их через запятую после `where`.
`class MyClass<T> where T : SomeBaseClass, ISomeInterface, new() { ... }`

**5. Перечислите все существующие ограничения на типы данных обобщения?**
- `where T : SomeBaseClass`: `T` должен быть или являться наследником `SomeBaseClass`.
- `where T : ISomeInterface`: `T` должен реализовывать интерфейс `ISomeInterface`.
- `where T : class`: `T` должен быть ссылочным типом.
- `where T : struct`: `T` должен быть типом значения (кроме `Nullable`).
- `where T : new()`: `T` должен иметь публичный конструктор без параметров.
- `where T : unmanaged`: `T` должен быть неуправляемым типом.
- `where U : T`: Параметр типа `U` должен быть или наследоваться от параметра `T`.

**6. Какое ограничение на тип задано в следующем фрагменте листинга?**
`class Test<T> where T : A { }`
Ограничение: `T` должен быть классом `A` или его наследником.

**7. Какое ограничение на тип задано в следующем фрагменте листинга?**
`class Test<T> where T : class { }`
Ограничение: `T` должен быть ссылочным типом (класс, интерфейс, делегат).

**8. Какое ограничение на тип задано в следующем фрагменте листинга?**
`class Test<T> where T : struct { }`
Ограничение: `T` должен быть типом значения (struct, enum, int, float и т.д.), который не может быть null.

**9. Приведите примеры, когда обобщенный класс может действовать как базовый или производный класс.**
- **Производный:** `class MyList<T> : List<T> { ... }` (наследуемся от другого обобщенного класса).
- **Базовый:** `class MyBase<T> { ... } class MyDerived : MyBase<int> { ... }` (наследуемся от "закрытого" обобщенного класса, указывая конкретный тип).

**10. В каких случаях в обобщениях может использоваться оператор `default`?**
Оператор `default(T)` используется для получения значения по умолчанию для параметра типа `T`. Это `null` для ссылочных типов и `0` (или эквивалент) для типов значений. Это полезно, когда нужно инициализировать переменную обобщенного типа.
`T myVar = default(T);`

**11. Поясните как использовать статические переменные в обобщенных классах.**
Статические члены в обобщенном классе уникальны для каждого конкретного типа, которым инстанциируется класс. Например, `MyGeneric<int>.StaticField` и `MyGeneric<string>.StaticField` — это две совершенно разные статические переменные, которые не зависят друг от друга.

**12. Приведите пример обобщенного интерфейса.**
Интерфейс `IComparable<T>`, который используется для определения порядка сортировки объектов.
```csharp
public interface IComparable<T>
{
    int CompareTo(T other);
}
```

**13. В чем отличие обобщенных классов от обобщенных структур?**
Основное отличие в том, что классы — это ссылочные типы, а структуры — типы значений.
- **Классы** хранятся в куче, передаются по ссылке. Поддерживают наследование.
- **Структуры** хранятся в стеке (в основном), передаются по значению (копируются). Не поддерживают наследование (но могут реализовывать интерфейсы).

**14. Какие классы для работы с файлами вы знаете? Приведите пример**
- `File`, `FileInfo`: для операций с файлами (создание, удаление, копирование).
- `Directory`, `DirectoryInfo`: для работы с каталогами.
- `Path`: для работы с путями к файлам.
- `StreamReader`, `StreamWriter`: для потокового чтения/записи текстовых файлов.
- `FileStream`: для потокового чтения/записи байтов.
- `JsonSerializer`, `XmlSerializer`: для сериализации/десериализации объектов.