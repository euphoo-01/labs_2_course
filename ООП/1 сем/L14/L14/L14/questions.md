# Ответы на вопросы (ЛР “Работа с потоками”)

## 1. Что такое процесс, домен, поток? Как они связаны между собой?

**Процесс** — это экземпляр выполняемой программы в ОС, у которого есть собственное виртуальное адресное пространство, набор ресурсов (дескрипторы файлов, сокеты и т.п.) и как минимум один поток выполнения. [file:1]

**Поток** — минимальная единица планирования выполнения в рамках процесса: у потока свой стек, регистры, состояние планировщика, но память процесса общая для всех потоков этого процесса. [file:1]

**Домен приложения (AppDomain)** — логическая “песочница” внутри процесса, исторически использовалась в .NET Framework для изоляции и выгрузки кода/сборок без остановки всего процесса. [file:1] В современном .NET (включая .NET 10) полноценная модель “создать/выгрузить AppDomain” не поддерживается (API помечено как устаревшее/неподдерживаемое), и вместо этого для выгрузки кода применяют `AssemblyLoadContext`. [web:7][web:14]

Связь:
- Один **процесс** содержит (как минимум) один **поток** (main thread). [file:1]
- В .NET Framework один процесс мог содержать несколько **AppDomain**, внутри которых выполнялись потоки. [file:1]
- В современном .NET изоляцию/выгрузку сборок делают через **AssemblyLoadContext**, а не через AppDomain. [web:14]

---

## 2. Как получить информацию о процессах?

В C# информация о процессах получается через `System.Diagnostics.Process`. [file:1]

Основные варианты:
- Получить все процессы: `Process.GetProcesses()` и затем читать свойства (`Id`, `ProcessName`, `StartTime`, `PriorityClass`, `TotalProcessorTime`, `Threads.Count`, `WorkingSet64` и т.д.). [file:1]
- Получить текущий процесс: `Process.GetCurrentProcess()`. [file:1]

Важно: часть свойств может бросать исключения из‑за прав доступа или особенностей системного процесса, поэтому обычно используют `try/catch` вокруг чтения отдельных свойств. [file:1]

---

## 3. Как создать и настроить домен?

### В .NET Framework (как в классических заданиях)
Создаётся `AppDomain.CreateDomain(...)`, при необходимости задаётся `AppDomainSetup` (база приложения, private bin path и т.п.), потом домен можно выгрузить через `AppDomain.Unload(domain)`. [file:1]

### В современном .NET (например, .NET 10)
“Полноценная” схема `CreateDomain/Unload` не поддерживается и помечена как устаревшая/неработающая, поэтому обычно:
- Исследуют `AppDomain.CurrentDomain` (имя, базовая директория, сборки). [file:1]
- Для сценария “загрузить и выгрузить сборку” используют `AssemblyLoadContext` с `isCollectible: true` и вызывают `Unload()`. [web:14]

---

## 4. Как создать и настроить поток?

Создание потока в C# делается через `System.Threading.Thread`: [file:1]
- Создаётся объект `Thread`, которому передают делегат (метод) или лямбда-выражение.
- До запуска можно настроить:
    - `Name` (имя потока),
    - `Priority` (приоритет),
    - `IsBackground` (фоновый/нефоновый). [file:1][web:42]

Запуск: `thread.Start()`. [file:1]  
Ожидание завершения: `thread.Join()`. [file:1]

---

## 5. В каких состояниях может быть поток?

Состояния задаются перечислением `ThreadState` (оно флаговое). [web:34]

На практике часто встречаются:
- `Unstarted` — поток создан, но `Start()` ещё не вызывался. [web:34]
- `Running` — поток запущен и выполняется (или готов к выполнению). [web:34]
- `WaitSleepJoin` — поток заблокирован (Sleep/Join/Wait на монитор/события). [web:34]
- `Stopped` — поток завершил выполнение. [web:34]
- `Background` — признак фонового потока (задаётся `IsBackground`). [web:34]

Есть и другие флаги (`AbortRequested`, `Aborted`, `Suspended` и т.п.), но часть из них относится к устаревшим/специфичным сценариям. [web:34]

---

## 6. Какие методы управления потоками вы знаете, для чего и как их использовать?

Ключевые методы/приёмы управления: [file:1]
- `Start()` — запустить поток. [file:1]
- `Join()` — дождаться завершения потока (можно с таймаутом). [file:1]
- `Thread.Sleep(ms)` — “усыпить” текущий поток на время (часто используется для демонстрации/имитации работы). [file:1]
- `IsAlive`/`ThreadState` — проверить, работает ли поток и в каком он состоянии. [web:34]

Про `Suspend/Resume/Abort`: в учебных заданиях их иногда упоминают как “управление потоком”, но в современном .NET эти подходы считаются опасными/устаревшими (могут приводить к deadlock и некорректным состояниям). [web:34] На практике вместо “паузы/продолжения” используют синхропримитивы:
- `ManualResetEvent(Slim)` — “пауза/продолжить” по сигналу,
- `CancellationToken` (чаще с `Task`) — корректная отмена. [file:1]

---

## 7. Какие приоритеты потока вы знаете?

Приоритет задаётся `ThreadPriority`: [web:42]
- `Lowest`
- `BelowNormal`
- `Normal` (обычно по умолчанию) [web:42]
- `AboveNormal`
- `Highest`

Важно понимать: приоритет — **относительная подсказка планировщику**. Реальный эффект зависит от ОС и нагрузки, и приоритет нельзя использовать как “синхронизацию” или гарантию порядка. [web:42]

---

## 8. Что такое пул потоков и для чего он используется?

Пул потоков — набор заранее созданных (или управляемых средой выполнения) потоков, которые переиспользуются для выполнения коротких фоновых работ без постоянного создания/уничтожения потоков. Это снижает накладные расходы и упрощает запуск множества мелких задач. [web:40]

В .NET таймер `System.Threading.Timer` выполняет callback **на потоке из пула потоков**, то есть это классический пример использования thread pool. [web:40]

---

## 9. Что такое критическая секция? Поясните использование.

Критическая секция — участок кода, который работает с общим ресурсом (общая переменная/коллекция/файл), и его нельзя выполнять одновременно нескольким потокам, иначе возникнет гонка данных. [file:1]

В C# критическую секцию чаще всего защищают `lock(obj)`:
- пока один поток внутри `lock`, остальные потоки ждут освобождения того же объекта-блокировки,
- это обеспечивает взаимное исключение при работе с общим ресурсом (например, запись в общий файл). [file:1]

---

## 10. Что такое мьютекс? Поясните использование

Мьютекс (Mutex) — примитив синхронизации для взаимного исключения, похожий по смыслу на `lock`, но (в отличие от `lock`) может использоваться **между процессами** (если мьютекс именованный). [file:1]

Использование:
- `mutex.WaitOne()` — захватить мьютекс (войти в критическую секцию),
- `mutex.ReleaseMutex()` — освободить,
- `WaitOne(timeout)` — ждать ограниченное время. [file:1]

---

## 11. Что такое семафор? Поясните использование

Семафор — примитив синхронизации, который ограничивает количество потоков, одновременно получающих доступ к ресурсу. [file:1]

Если мьютекс пропускает только 1 владельца, то семафор держит счётчик “свободных мест”:
- `WaitOne()` уменьшает счётчик (занимает ресурс),
- `Release()` увеличивает счётчик (освобождает ресурс). [file:1]

Типичный пример: есть N одинаковых ресурсов (каналы/соединения) — семафор ограничивает одновременных пользователей N. [file:1]

---

## 12. Что такое неблокирующие средства синхронизации?

Неблокирующие средства синхронизации — подходы, которые стараются не переводить поток в состояние ожидания на “тяжёлой” блокировке, а используют атомарные операции процессора. Часто это делается ради производительности на высоких нагрузках. [file:1]

Примеры в .NET:
- `Interlocked.Increment/Decrement/CompareExchange` — атомарные операции над переменными (без `lock`). [file:1]
- Потокобезопасные коллекции из `System.Collections.Concurrent` (внутри используют комбинацию блокировок и/или lock-free техник). [file:1]

Важно: неблокирующие техники сложнее в реализации и отладке; для большинства учебных задач и обычных приложений достаточно `lock/Monitor`. [file:1]

---

## 13. Для чего можно использовать класс Timer?

`System.Threading.Timer` — механизм выполнения метода (callback) **на потоке из пула потоков** через заданные интервалы. [web:40]

Типовые применения: [file:1]
- периодический опрос/мониторинг (например, проверка состояния),
- отложенные повторяющиеся действия (например, логирование метрик),
- регулярная очистка/обслуживание (например, чистка кэша),
- “тик” раз в N секунд для фоновой логики. [file:1]

Важные моменты:
- `dueTime` — задержка до первого запуска, `period` — интервал повторов, параметры можно менять через `Change(...)`. [web:40]
- callback выполняется в thread pool, поэтому внутри надо аккуратно работать с общими ресурсами (использовать синхронизацию). [web:40]
