# **№ 2 Windows Forms. Элементы управления** 

## Задание

Создать форму (или формы для ввода агрегируемых объектов). Разместить на
ней ЭУ для ввода/вывода информации об объекте (создать свои типы). На
форме разместить не менее **9-и различных типов ЭУ** (радиокнопки,
списки, поля ввода, метки, кнопки, слайдеры, календарь и т.д.).

Создать дополнительные кнопки для сохранения введенной информации и
вывода (отображения сохраненных данных). Запись сохраняемых объектов и
чтение выполнять в./из файл типа xml и/или json.

Добавить кнопку для расчета указанных в варианте значений (предложить
варианты для прибыли и расходов, формулу подсчета и вывести значение).

Выполнить валидацию вводимых пользователем данных.

+--------+-------------------------------------------------------------+
| В      | Задание                                                     |
| ариант |                                                             |
+========+:============================================================+
| 1, 9   | **Университет:** Объект -- «Студент». Поля: ФИО, возраст,   |
|        | специальность, дата рождения, курс, группа, средний балл,   |
|        | пол, адреса и др.                                           |
|        |                                                             |
|        | Агрегируемый объект -- «Место текущей работы студента».     |
|        | Поля: компания, должность, стаж и т.д.                      |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект -- «Адрес». Поля:       |
|        | город, индекс, улица, дом, квартира.*                       |
|        |                                                             |
|        | Исходя из введенных данных рассчитайте бюджет университета. |
+--------+-------------------------------------------------------------+
| 2, 10  | **Банк.** Объект -- «Счет». Поля: номер, тип вклада,        |
|        | баланс, дата открытия, владелец, подключение смс            |
|        | оповещения, подключение интернет-банкинга и т.д.            |
|        |                                                             |
|        | Агрегируемый объект -- «Владелец». Поля: ФИО, дата          |
|        | рождения, паспортные данные и т.д.                          |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект -- «История операций».  |
|        | Поля: тип операции (перевод, снятие...) , сумма, дата и     |
|        | т.д.*                                                       |
|        |                                                             |
|        | Исходя из введенных значений рассчитайте бюджет для каждого |
|        | отдельного владельца счета.                                 |
+--------+-------------------------------------------------------------+
| 3, 11  | **Учебный отдел**. Объект -- «Курс программирования». Поля: |
|        | название, возраст аудитории, сложность курса, количество    |
|        | лекций, количество лабораторных, вид контроля (экзамен,     |
|        | зачет), преподаватель и т.д.                                |
|        |                                                             |
|        | Агрегируемый объект: «Преподаватель». Поля: кафедра, ФИО,   |
|        | аудитория и т.д.                                            |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект -- «Список литературы». |
|        | Поля: название, автор, год и т.д.*                          |
|        |                                                             |
|        | Исходя из введенных значений рассчитайте бюджет для каждой  |
|        | возрастной группы.                                          |
+--------+-------------------------------------------------------------+
| 4, 12  | **Электронная библиотека.** Объект -- «Файл книги». Поля:   |
|        | тип (жанр), размер файла, название, количество страниц,     |
|        | издательство, год, список авторов, стоимость получения      |
|        | доступа к книге.                                            |
|        |                                                             |
|        | Агрегируемый объект -- «Автор»: ФИО, страна, ID и т.д.      |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект -- «Издательство».      |
|        | Поля: название, страна, город, год основания, частное или   |
|        | государственное, и т.д.*                                    |
|        |                                                             |
|        | Исходя из введенных значений рассчитайте отчисления         |
|        | авторам.                                                    |
+--------+-------------------------------------------------------------+
| 5, 13  | **Квартира.** Объект «Квартира». Поля: метраж, количество   |
|        | комнат, опции -- кухня, ванна, туалет, подвал, балкон и     |
|        | т.р., год постройки, тип материала, этаж и т.д.             |
|        |                                                             |
|        | Агрегируемый объект «Адрес». Поля: страна, город, район,    |
|        | улица, дом, корпус, номер квартиры и т.д.                   |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект -- «Застройщик».        |
|        | Обязательные поля: название, тип компании (ООО, ИП, ОАО и   |
|        | т.д.), юридический адрес, ИНН и т.д.*                       |
|        |                                                             |
|        | Исходя из введенных данных рассчитайте стоимость квартиры.  |
+--------+-------------------------------------------------------------+
| 6, 14  | **IT лаборатория.** Объект «Компьютер». Поля: тип           |
|        | компьютера (сервер, рабочая станция, ноутбук .....),        |
|        | процессор, видеокарта, размер и тип ОЗУ, размер и тип       |
|        | жесткого диска, дата приобретения и т.д.                    |
|        |                                                             |
|        | Агрегируемый объект «Процессор» - поля: производитель,      |
|        | серия, модель, количество ядер процессора, частота,         |
|        | максимальная частота, разрядность архитектуры, размер кэша  |
|        | L1-L3.                                                      |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект «Видеокарта». Поля:     |
|        | производитель, серия, модель, частота, объем памяти.*       |
|        |                                                             |
|        | Исходя из введенных данных рассчитайте стоимость компьютера |
|        | и всей лаборатории.                                         |
+--------+-------------------------------------------------------------+
| 7, 15  | **Аэропорт.** Объект «Самолет». Поля: ID, тип               |
|        | (пассажирский, грузовой, военный), модель (Airbus....) ,    |
|        | экипаж (список), количество пассажирских мест, год выпуска, |
|        | грузоподъемность, дата последнего тех. обслуживания и т.п.  |
|        |                                                             |
|        | Агрегируемый объект «Член Экипажа». Поля: ФИО, должность    |
|        | (пилот, стюардесса...), возраст, стаж и т.д.                |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект «Производитель». Поля:  |
|        | название, страна, год основания, типы производимых          |
|        | самолетов и т.д.*                                           |
|        |                                                             |
|        | Исходя из введенных значений рассчитайте прибыль,           |
|        | приносимую выбранным самолетом.                             |
+--------+-------------------------------------------------------------+
| 8, 16  | **Магазин.** Основной объект «Товар». Поля: название,       |
|        | инвентарный номер, размер, вес, тип, дата поступления,      |
|        | количество, цена, производитель.                            |
|        |                                                             |
|        | Агрегируемый объект «Производитель». Поля: организация,     |
|        | страна, адрес, телефон.                                     |
|        |                                                             |
|        | *Дополнительно: Агрегируемый объект «Продавец». Поля: ФИО,  |
|        | стаж, адрес и т.д.*                                         |
|        |                                                             |
|        | Исходя из введенных значений рассчитайте бюджет магазина.   |
+--------+-------------------------------------------------------------+

## Вопросы:

1.  Какое основное назначение технологии Windows Forms, ее особенности,
    преимущества и недостатки?

2.  Зачем используется класс Form? Назовите основные методы, свойства и
    события данного класса.

3.  Поясните структуру проекта и назначение всех файлов?

4.  Зачем нужен атрибут STAThreadAttribute?

5.  Как в вашем проекте используются события и делегаты?

6.  Объясните схему работы цепочек делегатов.

7.  Объясните механизм подписки и отмены подписки на события.

8.  Как создать вторую форму и передать туда данные? Есть ли другие
    способы?

9.  Как во время выполнения приложения добавить/удалить элемент
    управления?

## Дополнительные указания

### [Упрощенный пример]{.underline}

[using System;]{.mark}

[using System.Collections.Generic;]{.mark}

[using System.IO;]{.mark}

[using System.Linq;]{.mark}

[using System.Xml.Serialization;]{.mark}

[namespace NetW]{.mark}

[{]{.mark}

[class Program]{.mark}

[{]{.mark}

[static void Main()]{.mark}

[{]{.mark}

[var role = new List\<Role\> { new Role { Id = Guid.NewGuid(), Name =
\"User\" } };]{.mark}

[var users = new List\<User\>]{.mark}

[{]{.mark}

[new User(\"Ivan\", \"Ivanov\", 24)]{.mark}

[{]{.mark}

[Roles = role,]{.mark}

[Type = UserType.New,]{.mark}

[Sex = \'M\']{.mark}

[},]{.mark}

[new User(\"Nikita\", \"Nikolaev\", 24)]{.mark}

[{]{.mark}

[Roles = role,]{.mark}

[Type = UserType.New,]{.mark}

[Sex = \'M\']{.mark}

[},]{.mark}

[};]{.mark}

[XmlSerializeWrapper.Serialize(users, \"users.xml\");]{.mark}

[var deserializeUsers =
XmlSerializeWrapper.Deserialize\<List\<User\>\>(\"users.xml\");]{.mark}

[XmlSerializeWrapper.Serialize(users.First(), \"user.xml\");]{.mark}

[var deserializeUser =
XmlSerializeWrapper.Deserialize\<User\>(\"user.xml\");]{.mark}

[}]{.mark}

[}]{.mark}

[\[Serializable\]]{.mark}

[\[XmlRoot(Namespace = \"NetW\")\]]{.mark}

[\[XmlType(\"user\")\]]{.mark}

[public class User]{.mark}

[{]{.mark}

[public User()]{.mark}

[{]{.mark}

[Id = Guid.NewGuid();]{.mark}

[}]{.mark}

[public User(string firstName, string lastName, int age) :
this()]{.mark}

[{]{.mark}

[FirstName = firstName;]{.mark}

[LastName = lastName;]{.mark}

[Age = age;]{.mark}

[}]{.mark}

[\[XmlIgnore\]]{.mark}

[public char Sex { get; set; }]{.mark}

[\[XmlElement(ElementName = \"id\")\]]{.mark}

[public Guid Id { get; set; }]{.mark}

[\[XmlElement(ElementName = \"name\")\]]{.mark}

[public string FirstName { get; set; }]{.mark}

[\[XmlElement(ElementName = \"surname\")\]]{.mark}

[public string LastName { get; set; }]{.mark}

[\[XmlElement(ElementName = \"age\")\]]{.mark}

[public int Age { get; set; }]{.mark}

[\[XmlElement(ElementName = \"type\")\]]{.mark}

[public UserType Type { get; set; }]{.mark}

[\[XmlArray(\"roles\")\]]{.mark}

[\[XmlArrayItem(\"role\")\]]{.mark}

[public List\<Role\> Roles { get; set; }]{.mark}

[}]{.mark}

[\[Serializable\]]{.mark}

[public class Role]{.mark}

[{]{.mark}

[public Guid Id { get; set; }]{.mark}

[public string Name { get; set; }]{.mark}

[}]{.mark}

[\[Serializable\]]{.mark}

[public enum UserType]{.mark}

[{]{.mark}

[\[XmlEnum(\"L\")\]]{.mark}

[Locked,]{.mark}

[\[XmlEnum(\"N\")\]]{.mark}

[New]{.mark}

[}]{.mark}

[public static class XmlSerializeWrapper]{.mark}

[{]{.mark}

[public static void Serialize\<T\>(T obj, string filename)]{.mark}

[{]{.mark}

[XmlSerializer formatter = new XmlSerializer(typeof(T));]{.mark}

[using (FileStream fs = new FileStream(filename,
FileMode.OpenOrCreate))]{.mark}

[{]{.mark}

[formatter.Serialize(fs, obj);]{.mark}

[}]{.mark}

[}]{.mark}

[public static T Deserialize\<T\>(string filename)]{.mark}

[{]{.mark}

[T obj;]{.mark}

[using (FileStream fs = new FileStream(filename,
FileMode.OpenOrCreate))]{.mark}

[{]{.mark}

[XmlSerializer formatter = new XmlSerializer(typeof(T));]{.mark}

[obj = (T)formatter.Deserialize(fs);]{.mark}

[}]{.mark}

[return obj;]{.mark}

[}]{.mark}

[}]{.mark}

[}]{.mark}

### [Элементы управления]{.underline} 

Ознакомиться с классами ЭУ их методами, свойствами и примерами работы
можно на:

<https://msdn.microsoft.com/ru-ru/library/3xdhey7w(v=vs.110).aspx>

### [Классы для работы с XML JSON]{.underline}

<https://msdn.microsoft.com/ru-ru/library/2bcctyt8(v=vs.110).aspx>

https://docs.microsoft.com/ru-ru/dotnet/api/system.runtime.serialization.json?view=netframework-4.7.2

### [Проверка данных, вводимых пользователем]{.underline}

Практически любое приложение получает данные от пользователя. Если
разработчик хочет добиться стабильной работы своего приложения, то
следует придерживаться правила: «*Никакая информация введенная
пользователем не является полностью надежной и подлежит обязательной
проверке*». Проверка может осуществляться двумя способами.

*Проверка на уровне поля*

Иногда необходимо проверять данные сразу после их ввода. Самым
распространенным элементом управления для ввода данных является TextBox.
У него в частности есть свойство MaxLength, которое ограничивает число
символов, которые можно ввести в текстовое поле.

Элементы управления, принимающие ввод с клавиатуры генерируют следующие
события:

KeyDown, KeyUp -- любая клавиша нажата, любая клавиша отпущена. Когда
пользователь нажимает клавишу, которой соответствует значение ASCII,
генерируется событие KeyPress. Именно последнее событие применяется для
проверки «на лету» вводимых символов. При генерации события обработчик
получает экземпляр класса KeyPressEventArgs. У него есть два свойства:
KeyChar -- возвращает нажатый символ. Значение этого свойства можно
проверять с помощью статических методов класса Char на принадлежность к
той или иной группе.

Char.IsDigit, Char.IsLetter, Char.IsLetterOrDigit, Char.IsPunctuation,
Char.IsLower, Char.IsUpper.

Второе свойство -- Handled. Определяет, было ли событие обработано. Если
оно принимает значение false, то событие считается необработанным и
пересылается операционной системе для дальнейшей обработки, если true --
то событие считается обработанным и дальнейших действий не происходит.
Например, мы хотим организовать текстовое поле, куда можно вводить
только цифры.

private void myTextBox_KeyPress(object sender, KeyPressEventArgs e)

{

e.Handled = !Char.IsDigit(e.KeyChar);

}

Здесь обязательно отрицание. Однако, может получиться ситуация, когда
каждый отдельный символ является правильно введенным, но весь текст
является некорректным. Например, введенный текст является числом, но оно
выходит за допустимые логикой программы пределы.

Для такой проверки используется обработка события Validating, которое
генерируется ПЕРЕД потерей фокуса элементом управления. Событие будет
сгенерировано только в том случае, если свойство CausesValidation у
данного элемента и у элемента получающего фокус следующим установлено в
true. В обработчик события передается объект класса
System.ComponentModel.CancelEventArgs. У этого класса есть свойство
Cancel, если его установить в true, то дальнейшая обработка будет
приостановлена и фокус вернется к исходному элементу управления.

После успешной проверки значения элемента сгенерируется событие
Validated.

*Проверка на уровне формы*

Она позволяет проверить одновременно все поля формы. Например, в двух
текстовых полях задаются границы интервала, каждая из них может быть
нормальным числом, не выходящим за допустимые пределы, но при этом как
границы они будут неверны.

Для запуска проверки обычно используется событие Closing формы или
событие нажатия кнопки (OK, Применить и т.д.). В обработчик события
Closing также передается объект класса CancelEventArgs.

*Оповещение пользователя об ошибках ввода*

Делать это можно по разному:

-   с помощью модального окна с сообщением MessageBox.Show(\"Ошибка
    ввода\");

-   с помощью изменения цвета текста или фона текстового поля с неверно
    введенными данными;

-   с помощью компонента ErrorProvider

Компонент позволяет задать для каждого элемента управления текст
сообщения об ошибке, если этот текст задан, то рядом с элементом
управления появляется мигающий значок (его вид можно задать в свойствах
компонента). А при наведение указателя мыши на значок появляется текст
сообщения об ошибке.

if(notEmptyTextBox.Text.Equals(\"\"))

myErrorProvider.SetError(notEmptyTextBox, \"Поле не может быть
пустым\");

else

myErrorProvider.SetError(notEmptyTextBox, \"\");

**Примеры интерфейса:**

![](media/image1.png){width="4.332574365704287in"
height="5.8684612860892384in"}

![](media/image2.png){width="6.496527777777778in"
height="2.9305555555555554in"}
