# Объяснения к лабораторной работе №9

## Задание 1: Прототипное наследование (t1.js)

В этом задании мы создаем объекты для различных фигур, используя прототипное наследование в функциональном стиле. Этот подход является основополагающим в JavaScript.

### 1. Создание иерархии объектов

- **`Shape`**: Это базовый объект (прототип) для всех фигур. Он содержит общие свойства, такие как `color` и `type`. Любой объект, созданный на его основе, унаследует эти свойства.

- **`Object.create(Shape)`**: Этот метод создает новый пустой объект, у которого прототипом (скрытым свойством `[[Prototype]]`) становится объект `Shape`. Таким образом, `Square`, `Circle` и `Triangle` "наследуют" свойства и методы от `Shape`.

- **Цепочка прототипов**: Мы строим иерархию. Например, `smallSquare` наследует от `largeSquare`, который, в свою очередь, наследует от `Square`, а тот — от `Shape`. Если мы попытаемся получить свойство `color` у `smallSquare`, JavaScript сначала поищет его в самом `smallSquare`. Не найдя, он пойдет по цепочке прототипов к `largeSquare` и найдет там свойство `color: 'желтый'`.

- **Расширение свойств**: В объекте `triangleWithThreeLines` мы не просто заменяем свойство `lines`, а расширяем его, используя массив, унаследованный от `triangleWithOneLine`. Конструкция `[...triangleWithOneLine.lines, 'две линии по бокам']` создает новый массив, копируя в него старые элементы и добавляя новые.

### 2. Ответы на вопросы

- **Свойства зеленого круга**: Когда мы выводим объект `greenCircle` в консоль, мы видим все его свойства: как "собственные" (`color: 'зеленый'`, `radius: 80`), так и унаследованные (`type: 'круг'` от прототипа `Circle`).

- **Свойства треугольника**: Аналогично, у `triangleWithThreeLines` есть собственное свойство `lines`, а `color` и `type` он наследует по цепочке прототипов.

- **`hasOwnProperty('color')`**: Этот метод — ключевой для понимания наследования. Он проверяет, определено ли свойство **непосредственно в самом объекте**, а не в его прототипах. Для `smallSquare` он возвращает `false`, потому что свойство `color` находится не в нем, а в его прототипе `largeSquare`.

- **`Object.getPrototypeOf()`**: Этот метод позволяет "заглянуть" в цепочку прототипов и убедиться, что один объект действительно является прототипом для другого.

## Задание 2: Иерархия классов (t2.js)

Здесь мы используем более современный синтаксис `class` для создания той же идеи наследования. Это, по сути, "синтаксический сахар" над прототипным наследованием.

### `Human`
- **`class Human`**: Определяет "чертеж" для объектов-людей.
- **`constructor`**: Специальный метод, который вызывается при создании нового объекта (`new Human(...)`). Он инициализирует поля объекта.
- **`#birthYear`**: Синтаксис с `#` создает **приватное поле**. К нему нельзя получить доступ извне класса, что обеспечивает инкапсуляцию (скрытие) данных.
- **`get age()` / `set age()`**: Это геттер и сеттер.
    - **Геттер** выглядит как свойство, но на самом деле выполняет код (в нашем случае — вычисление) при каждом чтении `human.age`.
    - **Сеттер** выполняется при попытке присвоить значение (`human.age = 21`), позволяя выполнить дополнительную логику (вычисление нового года рождения).

### `Student`
- **`class Student extends Human`**: Ключевое слово `extends` указывает, что `Student` наследует все методы и свойства от `Human`.
- **`super(...)`**: В конструкторе дочернего класса **обязательно** нужно вызвать `super()`. Этот вызов запускает конструктор родительского класса (`Human`), чтобы он инициализировал свою часть полей (`firstName`, `lastName` и т.д.).
- **Переопределение методов**: `Student` имеет собственный метод `getInfo()`, который сначала вызывает родительскую версию (`super.getInfo()`) для получения основной информации, а затем добавляет к ней свою, студенческую.

### `Faculty`
- **Агрегация**: Этот класс не наследует, а **агрегирует** (содержит) другие объекты. Его поле `this.students` — это массив объектов `Student`.
- **Вычисляемые свойства**: `studentCount` и `groupCount` реализованы как геттеры. Они не хранят значение, а вычисляют его "на лету" на основе массива студентов. Это гарантирует,
что данные всегда будут актуальны.
- **`getDevCount()` / `getGroupList()`**: Эти методы демонстрируют, как можно работать с коллекцией объектов: они фильтруют массив студентов по определенным критериям (код специальности из зачетки или номер группы) и возвращают результат.
- **Разбор зачетки**: В `getDevCount` мы преобразуем номер зачетки в строку (`.toString()`) и берем символ по индексу (`[1]`), чтобы получить код специальности.
