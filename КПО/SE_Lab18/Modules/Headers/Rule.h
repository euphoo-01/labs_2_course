#pragma once
#include "GRB.h"
#define GRB_ERROR_SERIES 600

namespace GRB {
#define NS(n) Rule::Chain::N(n)
#define TS(n) Rule::Chain::T(n)
    // ------------------------------------------
    // ИЗМЕНЕНИЕ 1: Количество правил увеличено с 6 до 8
    // ------------------------------------------
    Greibach greibach(NS('S'), TS('$'), // стартовый символ, дно стека
                      8, // 👈 Изменено: 6 -> 8
                      Rule(NS('S'), GRB_ERROR_SERIES + 0, // 600 - неверная структура программы
                           4, // S->m{NrE;}; | tfi(F){NrE;};S | m{NrE;};S | tfi(F){NrE;}
                           Rule::Chain(8, TS('m'), TS('{'), NS('N'), TS('r'), NS('E'), TS(';'), TS('}'),TS(';')),
                           Rule::Chain(14, TS('t'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS('{'), NS('N'),
                                       TS('r'), NS('E'), TS(';'), TS('}'), TS(';'), NS('S')),
                           Rule::Chain(9, TS('m'), TS('{'), NS('N'), TS('r'), NS('E'), TS(';'), TS('}'), TS(';'),
                                       NS('S')),
                           Rule::Chain(12, TS('t'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS('{'), NS('N'),
                                       TS('r'), NS('E'), TS(';'), TS('}'))
                      ),
                      Rule(NS('N'), GRB_ERROR_SERIES + 1, // 601 - Ошибочный оператор
                           9, // N->dti;|rE;|i=E;|dtfi(F);|dtiN|rE;N|i=E;N|dtfi(F);N
                           Rule::Chain(4, TS('d'), TS('t'), TS('i'), TS(';')),
                           Rule::Chain(3, TS('r'), NS('E'), TS(';')),
                           Rule::Chain(4, TS('i'), TS('='), NS('E'), TS(';')),
                           Rule::Chain(4, TS('i'), TS('='), NS('E'), TS(';')), // Дубликат?
                           Rule::Chain(8, TS('d'), TS('t'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS(';')),
                           Rule::Chain(4, TS('d'), TS('t'), TS('i'), NS('N')),
                           Rule::Chain(4, TS('r'), NS('E'), TS(';'), NS('N')),
                           Rule::Chain(5, TS('i'), TS('='), NS('E'), TS(';'), NS('N')),
                           Rule::Chain(9, TS('d'), TS('t'), TS('f'), TS('i'), TS('('), NS('F'), TS(')'), TS(';'),
                                       NS('N'))
                      ),
                      Rule(NS('E'), GRB_ERROR_SERIES + 2, // 602 - Ошибка в выражении
                           8, // E->i|l|(E)|i(W)|iM|lM|(E)M|i(W)M
                           Rule::Chain(1, TS('i')),
                           Rule::Chain(1, TS('l')),
                           Rule::Chain(3, TS('('), NS('E'), TS(')')),
                           Rule::Chain(4, TS('i'), TS('('), NS('W'), TS(')')),
                           Rule::Chain(2, TS('i'), NS('M')),
                           Rule::Chain(2, TS('l'), NS('M')),
                           Rule::Chain(4, TS('('), NS('E'), TS(')'), NS('M')),
                           Rule::Chain(5, TS('i'), TS('('), NS('W'), TS(')'), NS('M'))
                      ),
                      // ------------------------------------------
                      // ИЗМЕНЕНИЕ 2: Добавление NS('F') для ошибки 603
                      // F -> t i , F | t i
                      // ------------------------------------------
                      Rule(NS('F'), GRB_ERROR_SERIES + 3, // 603 - Ошибка в параметрах функции
                           2,
                           // F -> t i , F (рекурсивный случай: 'integer x, ...')
                           Rule::Chain(4, TS('t'), TS('i'), TS(','), NS('F')),
                           // F -> t i (базовый случай: 'integer y')
                           Rule::Chain(2, TS('t'), TS('i'))
                      ),
                      // ------------------------------------------
                      // ИЗМЕНЕНИЕ 3: Добавление NS('W') для ошибки 604
                      // W -> E , W | E
                      // ------------------------------------------
                      Rule(NS('W'), GRB_ERROR_SERIES + 4, // 604 - Ошибка в параметрах вызываемой функции
                           2,
                           // W -> E , W (рекурсивный случай: 'x, ...')
                           Rule::Chain(3, NS('E'), TS(','), NS('W')),
                           // W -> E (базовый случай: 'y')
                           Rule::Chain(1, NS('E'))
                      ),
                      // ------------------------------------------
                      // ИЗМЕНЕНИЕ 4: Добавление NS('M') для полной логики ошибки 602
                      // M -> v E | e (epsilon, пустая строка, которую заменяет)
                      // Поскольку в ГНФ нельзя использовать e, M должен разворачиваться в символ,
                      // который может быть следующим за выражением (например, ; или )
                      // Предположим, M - это продолжение выражения после i или l
                      // И M - это оператор v E (v: +, -, *, /)
                      // Если M является опциональным продолжением:
                      // M -> v E | ; | ) | }
                      // Но в ваших правилах M используется только для продолжения выражения
                      // E -> i M
                      // E -> i v E | i
                      // => M -> v E
                      // M не должен быть пустым! Поскольку E уже имеет нерекурсивные ветки i | l | (E) | i(W)
                      // M должен быть определен так, чтобы он всегда начинался с терминала,
                      // а следующий символ выражения - это оператор v.
                      // M -> v E
                      // ------------------------------------------
                      Rule(NS('M'), GRB_ERROR_SERIES + 2, // Ошибка в выражении (продолжение)
                           1, // M -> v E
                           Rule::Chain(2, TS('v'), NS('E'))
                      )
    );
}